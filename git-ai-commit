#!/bin/bash

# git-ai-commit - Generate commit messages using AI based on git diff
# Usage: git-ai-commit [options]

set -e

# Default values
STAGED_ONLY=false
INCLUDE_CONTEXT=false
DRY_RUN=false
AI_PROVIDER="gemini"
MAX_DIFF_LINES=500
DEBUG_MODE="${DEBUG:-false}"

# API Configuration - can be overridden by environment variables
CLAUDE_API_URL="${CLAUDE_API_URL:-https://api.anthropic.com/v1/messages}"
OPENAI_API_URL="${OPENAI_API_URL:-https://api.openai.com/v1/chat/completions}"
GEMINI_API_URL="${GEMINI_API_URL:-https://generativelanguage.googleapis.com/v1beta}"
CLAUDE_MODEL="claude-3-sonnet-20240229"
OPENAI_MODEL="gpt-4"
GEMINI_MODEL="gemini-2.5-flash-lite"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Print debug message
debug() {
    if [[ "$DEBUG_MODE" == "true" || "$DEBUG_MODE" == "1" ]]; then
        echo -e "${MAGENTA}DEBUG: $1${NC}" >&2
    fi
}

# Print usage information
show_help() {
    cat << EOF
git-ai-commit - Generate commit messages using AI based on git diff

USAGE:
    git-ai-commit [OPTIONS]

OPTIONS:
    -s, --staged        Only analyze staged changes (default: all changes)
    -c, --context       Include more context in the analysis
    -d, --dry-run       Show the commit message without committing
    -p, --provider      AI provider to use (claude, openai, gemini) [default: claude]
    -l, --limit         Maximum number of diff lines to analyze [default: 500]
    -h, --help          Show this help message

EXAMPLES:
    git-ai-commit                    # Analyze all changes and commit
    git-ai-commit --staged           # Only analyze staged changes
    git-ai-commit --dry-run          # Show commit message without committing
    git-ai-commit --context          # Include more context in analysis

REQUIREMENTS:
    - git repository
    - curl or wget for HTTP requests
    - API key configured (ANTHROPIC_API_KEY, OPENAI_API_KEY, or GEMINI_API_KEY)
    - Active git changes to analyze

ENVIRONMENT VARIABLES:
    ANTHROPIC_API_KEY    API key for Claude (required for claude provider)
    OPENAI_API_KEY       API key for OpenAI (required for openai provider)
    GEMINI_API_KEY       API key for Gemini (required for gemini provider)
    GIT_AI_COMMIT_MODEL  Override default model
    CLAUDE_API_URL       Override Claude API base URL
    OPENAI_API_URL       Override OpenAI API base URL
    GEMINI_API_URL       Override Gemini API base URL
    DEBUG                Enable debug logging (true/1 to enable)

EOF
}

# Print error message and exit
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

# Print info message
info() {
    echo -e "${BLUE}Info: $1${NC}"
}

# Print success message
success() {
    echo -e "${GREEN}Success: $1${NC}"
}

# Print warning message
warn() {
    echo -e "${YELLOW}Warning: $1${NC}"
}

# Check if we're in a git repository
check_git_repo() {
    debug "Checking if current directory is a git repository"
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        error "Not in a git repository"
    fi
    debug "Git repository check passed"
}

# Check if required tools and API keys are available
check_dependencies() {
    debug "Checking dependencies for provider: $AI_PROVIDER"
    
    # Check for curl or wget
    if ! command -v curl &> /dev/null && ! command -v wget &> /dev/null; then
        error "curl or wget is required for HTTP requests"
    fi
    debug "HTTP client check passed (curl/wget available)"
    
    # Check for jq
    if ! command -v jq &> /dev/null; then
        warn "jq not found - JSON parsing may fail"
    else
        debug "jq check passed"
    fi
    
    # Check API key based on provider
    case $AI_PROVIDER in
        claude)
            if [[ -z "$ANTHROPIC_API_KEY" ]]; then
                error "ANTHROPIC_API_KEY environment variable is required for Claude provider"
            fi
            debug "Claude API key configured"
            debug "Using Claude API URL: $CLAUDE_API_URL"
            ;;
        openai)
            if [[ -z "$OPENAI_API_KEY" ]]; then
                error "OPENAI_API_KEY environment variable is required for OpenAI provider"
            fi
            debug "OpenAI API key configured"
            debug "Using OpenAI API URL: $OPENAI_API_URL"
            ;;
        gemini)
            if [[ -z "$GEMINI_API_KEY" ]]; then
                error "GEMINI_API_KEY environment variable is required for Gemini provider"
            fi
            debug "Gemini API key configured"
            debug "Using Gemini API URL: $GEMINI_API_URL"
            ;;
        *)
            error "Unsupported AI provider: $AI_PROVIDER"
            ;;
    esac
}

# Get git diff based on options
get_git_diff() {
    local diff_cmd="git diff"
    
    debug "Getting git diff with options - staged: $STAGED_ONLY, context: $INCLUDE_CONTEXT"
    
    if [[ "$STAGED_ONLY" == "true" ]]; then
        diff_cmd="git diff --staged"
    fi
    
    # Add context if requested
    if [[ "$INCLUDE_CONTEXT" == "true" ]]; then
        diff_cmd="$diff_cmd --unified=5"
    else
        diff_cmd="$diff_cmd --unified=3"
    fi
    
    debug "Executing command: $diff_cmd"
    
    # Get the diff and limit lines if specified
    local diff_output
    diff_output=$(eval "$diff_cmd" 2>/dev/null)
    
    if [[ -z "$diff_output" ]]; then
        if [[ "$STAGED_ONLY" == "true" ]]; then
            error "No staged changes found"
        else
            error "No changes found"
        fi
    fi
    
    # Limit diff lines if specified
    if [[ $MAX_DIFF_LINES -gt 0 ]]; then
        local total_lines
        total_lines=$(eval "$diff_cmd" 2>/dev/null | wc -l)
        debug "Git diff has $total_lines total lines"
        
        if [[ $total_lines -gt $MAX_DIFF_LINES ]]; then
            diff_output=$(echo "$diff_output" | head -n "$MAX_DIFF_LINES")
            warn "Diff truncated to $MAX_DIFF_LINES lines (was $total_lines lines)"
            debug "Diff truncated to $MAX_DIFF_LINES lines"
        fi
    fi
    
    debug "Git diff captured successfully ($(echo "$diff_output" | wc -l) lines)"
    echo "$diff_output"
}

# Make HTTP request using curl or wget
make_http_request() {
    local url="$1"
    local headers="$2"
    local data="$3"
    
    debug "Making HTTP request to: $url"
    debug "Request headers: Content-Type: application/json $headers"
    debug "Request data length: $(echo "$data" | wc -c) characters"
    
    # Show request body for debugging (pretty-printed JSON if possible)
    if [[ "$DEBUG_MODE" == "true" || "$DEBUG_MODE" == "1" ]]; then
        local formatted_json
        if command -v jq &> /dev/null; then
            formatted_json=$(echo "$data" | jq . 2>/dev/null) || formatted_json="$data"
        else
            formatted_json="$data"
        fi
        debug "Request body: $formatted_json"
    fi
    
    local response
    if command -v curl &> /dev/null; then
        debug "Using curl for HTTP request"
        
        # For logging purposes, create a display-friendly version of the command
        # where the data payload is safely escaped.
        if [[ "$DEBUG_MODE" == "true" || "$DEBUG_MODE" == "1" ]]; then
            local safe_data_for_log
            printf -v safe_data_for_log '%q' "$data"
            # Note: The logged command is a representation. The actual execution uses a pipe.
            # The header string is intentionally not quoted to allow shell word splitting.
            debug "Executing command (representation): echo $safe_data_for_log | curl -s -X POST '$url' --header 'Content-Type: application/json' --header \"$headers\" --data-binary @-"
        fi
        
        # Execute the command by piping the data to curl. This is safer than using eval
        # on the data, as it avoids shell parsing issues with special characters.
        # We still use eval to parse the headers string, which may contain multiple,
        # quoted arguments for providers like Claude. The URL is single-quoted
        # to protect it from being modified by eval.
        response=$(echo "$data" | eval "curl -s -X POST '$url' --header 'Content-Type: application/json' --header \"$headers\" --data-binary @-")

    elif command -v wget &> /dev/null; then
        debug "Using wget for HTTP request"
        
        if [[ "$DEBUG_MODE" == "true" || "$DEBUG_MODE" == "1" ]]; then
            local safe_data_for_log
            printf -v safe_data_for_log '%q' "$data"
            debug "Executing command (representation): echo $safe_data_for_log | wget -q -O- --header='Content-Type: application/json' --header $headers --post-data=@- '$url'"
        fi
        
        # The original implementation for wget was already using a pipe.
        # We add `eval` for consistency in header parsing, although it's less likely to be needed for wget.
        response=$(echo "$data" | eval "wget -q -O- --header='Content-Type: application/json' --header $headers --post-data=@- '$url'")
    else
        error "Neither curl nor wget available"
    fi
    
    local response_length=$(echo "$response" | wc -c)
    debug "HTTP response received: $response_length characters"
    
    # Show response for debugging (pretty-printed JSON if possible)
    if [[ "$DEBUG_MODE" == "true" || "$DEBUG_MODE" == "1" ]]; then
        local formatted_response
        if command -v jq &> /dev/null; then
            formatted_response=$(echo "$response" | jq . 2>/dev/null) || formatted_response="$response"
        else
            formatted_response="$response"
        fi
        
        # Limit output length for readability
        if [[ ${#formatted_response} -gt 1000 ]]; then
            local preview=$(echo "$formatted_response" | head -c 1000)
            debug "Response body (truncated): $preview..."
        else
            debug "Response body: $formatted_response"
        fi
    fi
    
    echo "$response"
}


# Generate commit message using Claude API
generate_commit_message_claude() {
    local diff_content="$1"
    local model="${GIT_AI_COMMIT_MODEL:-$CLAUDE_MODEL}"
    
    debug "Generating commit message using Claude API with model: $model"
    
    local prompt="Based on the following git diff, generate a concise and descriptive commit message following conventional commit format (type: description). Focus on what changed and why, not implementation details.

Git diff:
$diff_content

Requirements:
- Use conventional commit format: type(scope): description
- Keep the message under 72 characters for the first line
- Be specific about what changed
- Focus on the 'why' rather than the 'how'
- Use present tense, imperative mood
- Common types: feat, fix, docs, style, refactor, test, chore

Generate only the commit message, no additional text:"

    local json_data=$(cat <<EOF
{
    "model": "$model",
    "max_tokens": 100,
    "messages": [
        {
            "role": "user",
            "content": $(echo "$prompt" | jq -Rs .)
        }
    ]
}
EOF
)

    debug "Calling Claude API..."
    local response
    response=$(make_http_request "$CLAUDE_API_URL" \
               "\"x-api-key: $ANTHROPIC_API_KEY\" -H \"anthropic-version: 2023-06-01\"" \
               "$json_data")
    
    if [[ $? -ne 0 ]]; then
        debug "Claude API call failed"
        error "Failed to call Claude API"
    fi
    
    debug "Claude API response received, parsing..."
    
    # Check for API errors first
    local error_message=$(echo "$response" | jq -r '.error.message // empty' 2>/dev/null)
    if [[ -n "$error_message" ]]; then
        debug "Claude API returned error: $error_message"
        error "Claude API error: $error_message"
    fi
    
    # Extract message content from response
    local commit_message
    commit_message=$(echo "$response" | jq -r '.content[0].text' 2>/dev/null) || {
        debug "Failed to parse Claude API response. Raw response: $response"
        error "Failed to parse Claude API response"
    }
    
    debug "Claude API parsing successful. Commit message: '$commit_message'"
    echo "$commit_message"
}

# Generate commit message using OpenAI API
generate_commit_message_openai() {
    local diff_content="$1"
    local model="${GIT_AI_COMMIT_MODEL:-$OPENAI_MODEL}"
    
    debug "Generating commit message using OpenAI API with model: $model"
    
    local prompt="Based on the following git diff, generate a concise and descriptive commit message following conventional commit format (type: description). Focus on what changed and why, not implementation details.

Git diff:
$diff_content

Requirements:
- Use conventional commit format: type(scope): description
- Keep the message under 72 characters for the first line
- Be specific about what changed
- Focus on the 'why' rather than the 'how'
- Use present tense, imperative mood
- Common types: feat, fix, docs, style, refactor, test, chore

Generate only the commit message, no additional text:"

    local json_data=$(cat <<EOF
{
    "model": "$model",
    "max_tokens": 100,
    "messages": [
        {
            "role": "user",
            "content": $(echo "$prompt" | jq -Rs .)
        }
    ]
}
EOF
)

    debug "Calling OpenAI API..."
    local response
    response=$(make_http_request "$OPENAI_API_URL" \
               "Authorization: Bearer $OPENAI_API_KEY" \
               "$json_data")
    
    if [[ $? -ne 0 ]]; then
        debug "OpenAI API call failed"
        error "Failed to call OpenAI API"
    fi
    
    debug "OpenAI API response received, parsing..."
    
    # Check for API errors first
    local error_message=$(echo "$response" | jq -r '.error.message // empty' 2>/dev/null)
    if [[ -n "$error_message" ]]; then
        debug "OpenAI API returned error: $error_message"
        error "OpenAI API error: $error_message"
    fi
    
    # Extract message content from response
    local commit_message
    commit_message=$(echo "$response" | jq -r '.choices[0].message.content' 2>/dev/null) || {
        debug "Failed to parse OpenAI API response. Raw response: $response"
        error "Failed to parse OpenAI API response"
    }
    
    debug "OpenAI API parsing successful. Commit message: '$commit_message'"
    echo "$commit_message"
}

# Generate commit message using Gemini API
generate_commit_message_gemini() {
    local diff_content="$1"
    local model="${GIT_AI_COMMIT_MODEL:-$GEMINI_MODEL}"
    
    debug "Generating commit message using Gemini API with model: $model"
    
    local prompt="Based on the following git diff, generate a concise and descriptive commit message following conventional commit format (type: description). Focus on what changed and why, not implementation details.

Git diff:
$diff_content

Requirements:
- Use conventional commit format: type(scope): description
- Keep the message under 72 characters for the first line
- Be specific about what changed
- Focus on the 'why' rather than the 'how'
- Use present tense, imperative mood
- Common types: feat, fix, docs, style, refactor, test, chore

Generate only the commit message, no additional text:"

    local json_data=$(cat <<EOF
{
    "model": "$model",
    "messages": [
        {
            "role": "user",
            "content": $(echo "$prompt" | jq -Rs .)
        }
    ]
}
EOF
)

    local api_url="${GEMINI_API_URL}/chat/completions"
    
    debug "Calling Gemini API..."
    local response
    response=$(make_http_request "$api_url" \
               "Authorization: Bearer $GEMINI_API_KEY" \
               "$json_data")
    
    if [[ $? -ne 0 ]]; then
        debug "Gemini API call failed"
        error "Failed to call Gemini API"
    fi
    
    debug "Gemini API response received, parsing..."
    
    # Check for API errors first
    local error_message=$(echo "$response" | jq -r '.error.message // empty' 2>/dev/null)
    if [[ -n "$error_message" ]]; then
        debug "Gemini API returned error: $error_message"
        error "Gemini API error: $error_message"
    fi
    
    # Parse response (prioritize OpenAI-compatible format)
    local commit_message
    commit_message=$(echo "$response" | jq -r '.choices[0].message.content' 2>/dev/null) || {
        debug "Failed to parse Gemini API response. Raw response: $response"
        error "Failed to parse Gemini API response"
    }
    
    debug "Gemini API parsing successful. Commit message: '$commit_message'"
    echo "$commit_message"
}

# Generate commit message using AI
generate_commit_message() {
    local diff_content="$1"
    
    case $AI_PROVIDER in
        claude)
            generate_commit_message_claude "$diff_content"
            ;;
        openai)
            generate_commit_message_openai "$diff_content"
            ;;
        gemini)
            generate_commit_message_gemini "$diff_content"
            ;;
        *)
            error "Unsupported AI provider: $AI_PROVIDER"
            ;;
    esac
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -s|--staged)
                STAGED_ONLY=true
                shift
                ;;
            -c|--context)
                INCLUDE_CONTEXT=true
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -p|--provider)
                AI_PROVIDER="$2"
                shift 2
                ;;
            -l|--limit)
                MAX_DIFF_LINES="$2"
                shift 2
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                error "Unknown option: $1. Use --help for usage information."
                ;;
        esac
    done
}

# Main execution
main() {
    parse_args "$@"
    
    debug "Starting git-ai-commit with the following configuration:"
    debug "- AI Provider: $AI_PROVIDER"
    debug "- Staged Only: $STAGED_ONLY"
    debug "- Include Context: $INCLUDE_CONTEXT"
    debug "- Dry Run: $DRY_RUN"
    debug "- Max Diff Lines: $MAX_DIFF_LINES"
    debug "- Debug Mode: $DEBUG_MODE"
    
    info "Checking git repository..."
    check_git_repo
    
    info "Checking dependencies..."
    check_dependencies
    
    info "Analyzing changes..."
    local diff_content
    diff_content=$(get_git_diff)
    
    info "Generating commit message using $AI_PROVIDER..."
    local commit_message
    commit_message=$(generate_commit_message "$diff_content")
    
    if [[ -z "$commit_message" ]]; then
        debug "Empty commit message received from AI provider"
        error "Failed to generate commit message"
    fi
    
    debug "Raw commit message from AI: '$commit_message'"
    
    # Clean up the commit message (remove any extra whitespace/newlines)
    commit_message=$(echo "$commit_message" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | head -n 1)
    
    debug "Cleaned commit message: '$commit_message'"
    
    echo
    echo -e "${GREEN}Generated commit message:${NC}"
    echo -e "${YELLOW}$commit_message${NC}"
    echo
    
    if [[ "$DRY_RUN" == "true" ]]; then
        info "Dry run mode - not committing"
        debug "Exiting due to dry run mode"
        exit 0
    fi
    
    # Ask for confirmation
    read -p "Do you want to commit with this message? [y/N] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        debug "User confirmed commit"
        if [[ "$STAGED_ONLY" == "false" ]]; then
            info "Adding all changes to staging area..."
            debug "Running: git add -A"
            git add -A
        fi
        
        info "Creating commit..."
        debug "Running: git commit -m \"$commit_message\""
        git commit -m "$commit_message"
        success "Commit created successfully!"
    else
        info "Commit cancelled"
        debug "User cancelled commit"
    fi
}

# Run main function with all arguments
main "$@"
